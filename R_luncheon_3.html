<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>R_luncheon_3.utf8</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="js/google-analytics.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">SCCWRP R training</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="Intro_to_R.html">Introduction to R</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Data wrangling
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Data_Wrangling_1.html">Part 1</a>
    </li>
    <li>
      <a href="Data_Wrangling_2.html">Part 2</a>
    </li>
  </ul>
</li>
<li>
  <a href="Viz_and_Graphics.html">Viz and graphics</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    R luncheons
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="R_luncheon_1.html">R luncheon 1</a>
    </li>
    <li>
      <a href="R_luncheon_2.html">R luncheon 2</a>
    </li>
    <li>
      <a href="R_luncheon_3.html">R luncheon 3</a>
    </li>
    <li>
      <a href="R_luncheon_4.html">R luncheon 4</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<div id="r-luncheon-3" class="section level1">
<h1>R luncheon 3</h1>
<div id="lesson-outline" class="section level2">
<h2>Lesson Outline</h2>
<ul>
<li><a href="#vector-data">Vector data</a></li>
<li>[Simple features overview]</li>
<li><a href="#creating-spatial-data-with-simple-features">Creating spatial data with simple features</a></li>
<li><a href="#basic-geospatial-analysis">Basic geospatial analysis</a></li>
</ul>
<p>Welcome to the third R luncheon! By popular demand, the final two luncheons will explore using R for geospatial analsyis and mapping. Today’s session will focus on geospatial analysis using the new <a href="https://r-spatial.github.io/sf/">simple features</a> package and our final session will focus on creating publication ready maps in R. We will focus entirely on working with vector data in these next two lessons, but checkout the <a href="https://cran.r-project.org/web/packages/raster/">raster</a> and <a href="https://cran.r-project.org/web/packages/rgdal/index.html">rgdal</a> packages if you want to work with raster data in R. There are several useful vignettes in the raster link.</p>
<p>Please note that this is not an introduction to R and you are also expected to have an understanding of basic geospatial concepts for these next two sessions. You can visit any of the other topics on our <a href="index.html">main page</a> for a refresher on some of the R basics. In the mean time, feel free to ask plenty of questions as we go through today’s lesson!</p>
<p>The goals for today are:</p>
<ol style="list-style-type: decimal">
<li><p>Understand the vector data structure</p></li>
<li><p>Understand how to import vector data in R</p></li>
<li><p>Understand how R stores spatial data using the simple features package</p></li>
<li><p>Execute basic geospatial functions in R</p></li>
</ol>
</div>
<div id="vector-data" class="section level2">
<h2>Vector data</h2>
<p>Most of us should be familiar with the basic types of spatial data and their components. We’re going to focus entirely on vector data for this lesson because these data are easily conceptualized as <strong>features</strong> or discrete objects with spatial information. More about this later. Raster data by contrast are stored in a regular grid where the cells of the grid are associated with values. Raster data are more common for data with continous coverage, such as climate or weather layers.</p>
<p>Vector data come in three flavors. The simplest of is a <strong>point</strong>, which is a 0-dimensional feature that can be used to represent a specific location on the earth, such as a single tree or an entire city. Linear, 1-dimensional features can be represented with points (or vertices) that are connected by a path to form a <strong>line</strong> and when many points are connected these form a <strong>polyline</strong>. Finally, when a polyline’s path returns to its origin to represent an enclosed space, such as a forest, watershed boundary, or lake, this forms a <strong>polygon</strong>.</p>
<p><img src="figure/pts-lines-polys.png" alt="https://earthdatascience.org/courses/earth-analytics/spatial-data-r/intro-vector-data-r/" /> <em>Image <a href="https://earthdatascience.org/courses/earth-analytics/spatial-data-r/intro-vector-data-r/">source</a></em></p>
<p>All vector data are represented similarly, whether they’re points, lines or polygons. Points are defined by a single coordinate location, whereas a line or polygon is several points with a grouping variable that distinguishes one object from another. In all cases, the aggregate dataset is composed of one or more features of the same type (points, lines, or polygons).</p>
<p>There are two other pieces of information that are included with vector data. The <strong>attributes</strong> that can be associated with each feature and the <strong>coordinate reference system</strong> or <strong>CRS</strong>. The attributes can be any supporting information about a feature, such as a town name or summary data about the features. You can identify attributes as anything in a spatial dataset that is not explicitly used to define the location of the features.</p>
<p>The CRS is used to establish a frame of reference for the locations in your spatial data. The chosen CRS ensures that all features are correctly referenced relative to each other, especially between different datasets. As a simple example, imagine comparing length measurements for two objects where one was measured in centimeters and another in inches. If you didn’t know the unit of measurement, you could not compare relative lengths. The CRS is similar in that it establishes a common frame of reference, but for spatial data. An added complication with spatial data is that location can be represented in both 2-dimensional or 3-dimensional space. This is beyond the scope of this lesson, but you should be sure that</p>
<ol style="list-style-type: decimal">
<li><p>the CRS is the same when comparing between datasets, and</p></li>
<li><p>the CRS is appropriate for the region you’re looking at.</p></li>
</ol>
<p><img src="figure/crs-comparisons.jpg" /></p>
<p><em>Image <a href="https://nceas.github.io/oss-lessons/spatial-data-gis-law/1-mon-spatial-data-intro.html">source</a></em></p>
<p>To summarize, vector data include the following:</p>
<ol style="list-style-type: decimal">
<li><p>spatial data (e.g., latitude, longitude) as points, lines, or polygons</p></li>
<li><p>attributes</p></li>
<li><p>a coordinate reference system</p></li>
</ol>
</div>
<div id="simple-features" class="section level2">
<h2>Simple features</h2>
<p>R has a long history of packages for working with spatial data. For many years, the <a href="https://cran.r-project.org/web/packages/sp/index.html">sp</a> package was the standard and most widely used toolset for working with spatial data in R. This package laid the foundation for creating spatial data classes and methods in R, but unfortunately it’s development predated a lot of the newer tools that are built around the <a href="https://www.tidyverse.org/">tidyverse</a>. This makes it incredibly difficult to incorporate sp data objects with the more commonly used data analysis workflows.</p>
<p>The <a href="https://r-spatial.github.io/sf/">simple features</a> or sf package was developed to streamline the use of spatial data in R and to align its functionality with those provided in the tidyverse. The <code>sf</code> package provides <a href="https://en.wikipedia.org/wiki/Simple_Features">simple features access</a> for R and without a doubt, <code>sf</code> will replace <code>sp</code> as the fundamental spatial model in R for vector data. Packages are already being updated around <code>sf</code>.</p>
<p>Simple Features is a hierarchical data model that represents a wide range of geometry types - it includes all common vector geometry types (but does not include raster) and even allows geometry collections, which can have multiple geometry types in a single object. From the first sf package vignette we see:</p>
<p><img src="figure/sf_objects.png" /></p>
<p>You’ll notice that these are the same features we described above, but the sf package allows implementation of “multi” features and geometry collections that include more than one type of feature.</p>
</div>
<div id="creating-spatial-data-with-simple-features" class="section level2">
<h2>Creating spatial data with simple features</h2>
<p>Let’s get setup for today:</p>
<ol style="list-style-type: decimal">
<li><p>Open RStudio and create a new project.</p></li>
<li><p>In the new project directory, create a folder called “data”.</p></li>
<li>Download <a href="https://sccwrp.github.io/SCCWRP_R_training/data/GIS_data.zip">this</a> zipped folder to your computer (anywhere) and copy its contents to the “data” folder in your project.<br />
a</li>
<li><p>From the file menu, open a new script within the project. At the top of the script, install the sf package if you haven’t done so and load the package after installation.</p></li>
</ol>
<pre class="r"><code>install.package(&#39;sf&#39;)
library(sf)</code></pre>
<p>After the package is loaded, you can check out all of the methods that are available for <code>sf</code> data objects. Many of these names will look familiar if you’ve done geospatial analysis before. We’ll use some of these a little bit later.</p>
<pre class="r"><code>methods(class = &#39;sf&#39;)</code></pre>
<pre><code>##  [1] $&lt;-                   [                     [[&lt;-                 
##  [4] aggregate             anti_join             arrange              
##  [7] as.data.frame         cbind                 coerce               
## [10] dbDataType            dbWriteTable          distinct             
## [13] filter                full_join             group_by             
## [16] identify              initialize            inner_join           
## [19] left_join             merge                 mutate               
## [22] plot                  print                 rbind                
## [25] rename                right_join            sample_frac          
## [28] sample_n              select                semi_join            
## [31] show                  slice                 slotsFromS3          
## [34] st_agr                st_agr&lt;-              st_as_sf             
## [37] st_bbox               st_boundary           st_buffer            
## [40] st_cast               st_centroid           st_collection_extract
## [43] st_convex_hull        st_coordinates        st_crs               
## [46] st_crs&lt;-              st_difference         st_geometry          
## [49] st_geometry&lt;-         st_intersection       st_is                
## [52] st_line_merge         st_node               st_point_on_surface  
## [55] st_polygonize         st_precision          st_segmentize        
## [58] st_set_precision      st_simplify           st_snap              
## [61] st_sym_difference     st_transform          st_triangulate       
## [64] st_union              st_voronoi            st_wrap_dateline     
## [67] st_write              st_zm                 summarise            
## [70] transmute             ungroup              
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>All of the functions and methods in sf are prefixed with st_, which stands for ‘spatial and temporal’. This is kind of confusing but this is in reference to standard methods avialable in <a href="https://en.wikipedia.org/wiki/PostGIS">PostGIS</a>, an open-source backend that is used by many geospatial platforms. An advantage of this prefixing is all commands are easy to find with command-line completion in sf, in addition to naming continuity with existing software.</p>
<p>There are two ways to create a spatial data object in R, i.e., an <code>sf</code> object, using the sf package.</p>
<ol style="list-style-type: decimal">
<li><p>Directly import a shapefile</p></li>
<li><p>Convert an existing R object with latitude/longitude data</p></li>
</ol>
<p>We’ll import a shapefile first and look at its structure so we can better understand the <code>sf</code> object. The <code>st_read()</code> function can be used for import. Setting <code>quiet = T</code> will keep R from being chatty when it imports the data.</p>
<pre class="r"><code>polys &lt;- st_read(&#39;data/Bight13_MPAs_Offshore.shp&#39;, quiet = T)
polys</code></pre>
<pre><code>## Simple feature collection with 25 features and 2 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: 182769 ymin: 3599568 xmax: 488069.6 ymax: 3818896
## epsg (SRID):    26911
## proj4string:    +proj=utm +zone=11 +datum=NAD83 +units=m +no_defs
## First 10 features:
##           Region      MPA_Name                       geometry
## 1   Campus Point  Campus Point MULTIPOLYGON (((238555.2 38...
## 2         Naples        Naples MULTIPOLYGON (((230453.5 38...
## 3      Kashtayit     Kashtayit MULTIPOLYGON (((205345.2 38...
## 4   Abalone Cove  Abalone Cove MULTIPOLYGON (((372581.6 37...
## 5  Point Vicente Point Vicente MULTIPOLYGON (((366154.7 37...
## 6     Point Dume    Point Dume MULTIPOLYGON (((333051.1 37...
## 7     Point Dume    Point Dume MULTIPOLYGON (((331883.2 37...
## 8     Dana Point    Dana Point MULTIPOLYGON (((430436.8 37...
## 9   Laguna Beach  Laguna Beach MULTIPOLYGON (((426176.2 37...
## 10  Laguna Beach  Laguna Beach MULTIPOLYGON (((425246.4 37...</code></pre>
<p>What does this show us? Let’s break it down.</p>
<p><img src="figure/sf_struct.png" /></p>
<ul>
<li>in green, metadata describing components of the <code>sf</code> object</li>
<li>in yellow a simple feature: a single record, or data.frame row, consisting of attributes and geometry</li>
<li>in blue a single simple feature geometry (an object of class <code>sfg</code>)</li>
<li>in red a simple feature list-column (an object of class <code>sfc</code>, which is a column in the data.frame)</li>
</ul>
<p>We’ve just imported a multipolygon dataset with 25 features and 2 fields. The dataset is projected using the UTM Zone 11 CRS. You’ll notice that the actual dataset looks very similar to a regular <code>data.frame</code>, with some interesting additions. The header includes some metadata about the <code>sf</code> object and the <code>geometry</code> column includes the actual spatial information for each feature.</p>
<p>Easy enough, but what if we have point data that’s not a shapefile? You can create an <code>sf</code> object from any existing <code>data.frame</code> so long as the data include coordinate information (e.g., lat/lon columns) and you know CRS (or can make an educated guess). Let’s first import a regular dataset with lat/lon columns.</p>
<pre class="r"><code>stations &lt;- read.csv(&#39;data/AllBightStationLocations.csv&#39;, stringsAsFactors = F)
str(stations)</code></pre>
<pre><code>## &#39;data.frame&#39;:    1867 obs. of  5 variables:
##  $ FID      : int  0 1 2 3 4 5 6 7 8 9 ...
##  $ StationID: chr  &quot;1001&quot; &quot;1003&quot; &quot;1005&quot; &quot;1014&quot; ...
##  $ Bight    : int  1994 1994 1994 1994 1994 1994 1994 1994 1994 1994 ...
##  $ Latitude : num  34 34 34 34 34 ...
##  $ Longitude: num  -119 -119 -119 -119 -118 ...</code></pre>
<p>The <code>st_as_sf()</code> function can do the trick but we have to tell it which column is the x-coordinates and which is the y-coordinates. We also have to specify a CRS - this is just a text string or number in a standard format for geospatial data. A big part of working with spatial data is keeping track of reference systems between different datasets. Remember that valid comparisons between datasets are only possible if the CRS is shared.</p>
<p>There are many, many types of reference systems and plenty of resources online that provide detailed explanations (see <a href="http://www.spatialreference.org/">spatialreference.org</a> or <a href="https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/OverviewCoordinateReferenceSystems.pdf">this guide</a> from NCEAS). For now, just realize that we can use a simple text string to indicate which CRS we want. For the station locations, it’s a safe bet to use the standard geographic projection with the WGS84 datum since the data include lat/lon.</p>
<pre class="r"><code>stations &lt;- stations %&gt;% 
  st_as_sf(coords = c(&#39;Longitude&#39;, &#39;Latitude&#39;), crs = &#39;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs&#39;)</code></pre>
<p>Now we can see the data in full <code>sf</code> glory.</p>
<pre class="r"><code>stations</code></pre>
<pre><code>## Simple feature collection with 1867 features and 3 fields
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: -120.6092 ymin: 32.04718 xmax: -117.0871 ymax: 34.46742
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs
## First 10 features:
##    FID StationID Bight                   geometry
## 1    0      1001  1994 POINT (-118.6077 33.98533)
## 2    1      1003  1994    POINT (-118.569 33.984)
## 3    2      1005  1994  POINT (-118.5373 33.9825)
## 4    3      1014  1994 POINT (-118.5588 33.97417)
## 5    4      1019  1994   POINT (-118.48 33.97067)
## 6    5      1025  1994  POINT (-118.476 33.96833)
## 7    6      1026  1994   POINT (-118.4965 33.967)
## 8    7      1027  1994 POINT (-118.5138 33.94867)
## 9    8      1028  1994 POINT (-118.5882 33.96583)
## 10   9       103  1994 POINT (-120.1839 34.42055)</code></pre>
<p>These two datasets describe some relevant information about our Bight sampling program. The <code>stations</code> data includes all locations that have been sampled from 1993 to 2013 and the <code>polys</code> data show locations of marine protected areas (MPAs) in the Bight. We might be interested in knowing which stations occur in MPAs, how many stations, or when they were sampled. We can address all of these questions in R, but before we proceed we need to make sure the two datasets share a CRS.</p>
<pre class="r"><code>st_crs(polys)</code></pre>
<pre><code>## Coordinate Reference System:
##   EPSG: 26911 
##   proj4string: &quot;+proj=utm +zone=11 +datum=NAD83 +units=m +no_defs&quot;</code></pre>
<pre class="r"><code>st_crs(stations)</code></pre>
<pre><code>## Coordinate Reference System:
##   EPSG: 4326 
##   proj4string: &quot;+proj=longlat +datum=WGS84 +no_defs&quot;</code></pre>
<p>You’ll have to choose one of the reference systems to use as the common format. Either one will work but sometimes it’s better to go with the UTM format since it references location using actual units of measurement, i.e., meters. This can make spatial analyses simpler, such as as estimating areas or spatial overlap between datasets. The <code>st_transform()</code> function can be used to transform an existing CRS for an <code>sf</code> obect to another.</p>
<pre class="r"><code>stations &lt;- stations %&gt;% 
  st_transform(crs = st_crs(polys))</code></pre>
<p>We can verify that both are now projected to UTM zone 11.</p>
<pre class="r"><code>st_crs(polys)</code></pre>
<pre><code>## Coordinate Reference System:
##   EPSG: 26911 
##   proj4string: &quot;+proj=utm +zone=11 +datum=NAD83 +units=m +no_defs&quot;</code></pre>
<pre class="r"><code>st_crs(stations)</code></pre>
<pre><code>## Coordinate Reference System:
##   EPSG: 26911 
##   proj4string: &quot;+proj=utm +zone=11 +datum=NAD83 +units=m +no_defs&quot;</code></pre>
</div>
<div id="basic-geospatial-analysis" class="section level2">
<h2>Basic geospatial analysis</h2>
<p>As with any analysis, let’s take a look at the data to see what we’re dealing with before we start comparing the two.</p>
<pre class="r"><code>plot(stations)</code></pre>
<p><img src="R_luncheon_3_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre class="r"><code>plot(polys)</code></pre>
<p><img src="R_luncheon_3_files/figure-html/unnamed-chunk-11-2.png" width="672" /></p>
<p>So we have lots of stations and not a whole lot of MPAs. You’ll also notice that the default plotting method for <code>sf</code> objects is to create one plot per attribute. This is intended behavior but sometimes is not that useful. Maybe we just want to see where the data are located independent of any of the attributes. We can accomplish by plotting only the geometry of the <code>sf</code> object.</p>
<pre class="r"><code>plot(st_geometry(stations))</code></pre>
<p><img src="R_luncheon_3_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<pre class="r"><code>plot(st_geometry(polys))</code></pre>
<p><img src="R_luncheon_3_files/figure-html/unnamed-chunk-12-2.png" width="672" /></p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
